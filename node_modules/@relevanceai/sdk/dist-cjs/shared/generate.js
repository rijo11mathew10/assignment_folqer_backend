"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const fs_1 = require("fs");
const openapi_typescript_1 = __importDefault(require("openapi-typescript"));
const serviceConfigs_1 = require("./serviceConfigs");
// download schema using cross-fetch
// convert to sdk with typescript, can supply middleware methods that will be run ???
function GetFlattenedSchema(schema) {
    var _a, _b, _c;
    if (!schema.paths)
        throw new Error('No paths in schema ${config.schema_url}');
    const final = [];
    for (const [path, methods] of Object.entries(schema.paths)) {
        for (const [method, pathData] of Object.entries(methods)) {
            const operation = pathData; // object.entries didnt work here
            const operationSummaryName = (_c = ((_b = (_a = operation === null || operation === void 0 ? void 0 : operation.operationId) !== null && _a !== void 0 ? _a : operation === null || operation === void 0 ? void 0 : operation.summary) !== null && _b !== void 0 ? _b : `${path}-${method}`)) === null || _c === void 0 ? void 0 : _c.replace(/[^A-Za-z0-9]/g, "");
            final.push({ path, method, operation, operationSummaryName });
        }
    }
    return final;
}
async function GenerateSDKFromOpenAPISchema({ config }) {
    const openapiSchema = await (await (0, cross_fetch_1.default)(config.schema_url)).json();
    const typescriptOutput = 'interface definitions {[id:string]:any};\n' + (await (0, openapi_typescript_1.default)(openapiSchema));
    let sdkText = '';
    const pipeline = [
        () => {
            sdkText += `import {CommandInput,_GenericClient,CommandOutput,_ClientInput,_GenericMethodOptions} from '../shared/BaseClient';
      import {operations} from './_${config.name}SchemaTypes';
`;
        },
        () => {
            for (const { path, method, operation, operationSummaryName } of GetFlattenedSchema(openapiSchema)) {
                if (method.toLowerCase() !== 'get' && operation.requestBody) {
                    sdkText += `
  export type ${operationSummaryName}Input = operations['${operation.operationId}']['requestBody']['content']['application/json']`;
                }
                else {
                    sdkText += `
  export type ${operationSummaryName}Input = {}`;
                }
                sdkText += `
export type ${operationSummaryName}Output = operations['${operation.operationId}']['responses']['200']['content']['application/json']`;
            }
        },
        () => {
            sdkText += `
export class ${config.name}Client  extends _GenericClient {
  constructor(config:_ClientInput){
    super({...config,service_name:'${config.name}'});
  }`;
        },
        () => {
            for (const { path, method, operationSummaryName } of GetFlattenedSchema(openapiSchema)) {
                sdkText += `
  public async ${operationSummaryName}(
    input: CommandInput<${operationSummaryName}Input>,
    options?: _GenericMethodOptions
  ):Promise<CommandOutput<${operationSummaryName}Output>> {
    return this.SendRequest({
      input,
      method:'${method}',
      path:'${path}',
      options
    });
  }`;
            }
        },
        () => {
            sdkText += '}';
        }
    ];
    for (const fn of pipeline)
        fn();
    await fs_1.promises.writeFile(`./src/generated/${config.name}.ts`, sdkText);
    await fs_1.promises.writeFile(`./src/generated/_${config.name}SchemaTypes.ts`, typescriptOutput);
}
async function GenerateSDKS() {
    let indexFileContent = '';
    for (const config of Object.values(serviceConfigs_1.serviceConfigs)) {
        GenerateSDKFromOpenAPISchema({ config });
        indexFileContent += `export * from "./${config.name}";\n`;
    }
    await fs_1.promises.writeFile(`./src/generated/index.ts`, indexFileContent);
}
GenerateSDKS();
